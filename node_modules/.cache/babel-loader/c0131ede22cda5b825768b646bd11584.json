{"ast":null,"code":"import _slicedToArray from \"E:\\\\testprojects\\\\CoolSwap-interface\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"E:\\\\testprojects\\\\CoolSwap-interface\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport { CurrencyAmount, ETHER, JSBI, Percent, Price } from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nvar ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  return useSelector(function (state) {\n    return state.mint;\n  });\n}\nexport function useMintActionHandlers(noLiquidity) {\n  var dispatch = useDispatch();\n  var onFieldAInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue: typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  var onFieldBInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue: typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput: onFieldAInput,\n    onFieldBInput: onFieldBInput\n  };\n}\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  var _currencyBalances, _parsedAmounts, _currencyBalances$Fie, _currencyBalances$Fie2;\n  var _useActiveWeb3React = useActiveWeb3React(),\n    account = _useActiveWeb3React.account,\n    chainId = _useActiveWeb3React.chainId;\n  var _useMintState = useMintState(),\n    independentField = _useMintState.independentField,\n    typedValue = _useMintState.typedValue,\n    otherTypedValue = _useMintState.otherTypedValue;\n  var dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\n\n  // tokens\n  var currencies = useMemo(function () {\n    var _ref;\n    return _ref = {}, _defineProperty(_ref, Field.CURRENCY_A, currencyA !== null && currencyA !== void 0 ? currencyA : undefined), _defineProperty(_ref, Field.CURRENCY_B, currencyB !== null && currencyB !== void 0 ? currencyB : undefined), _ref;\n  }, [currencyA, currencyB]);\n\n  // pair\n  var _usePair = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]),\n    _usePair2 = _slicedToArray(_usePair, 2),\n    pairState = _usePair2[0],\n    pair = _usePair2[1];\n  var totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  var noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO));\n\n  // balances\n  var balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  var currencyBalances = (_currencyBalances = {}, _defineProperty(_currencyBalances, Field.CURRENCY_A, balances[0]), _defineProperty(_currencyBalances, Field.CURRENCY_B, balances[1]), _currencyBalances);\n\n  // amounts\n  var independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  var dependentAmount = useMemo(function () {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      var wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\n      var _ref2 = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)],\n        tokenA = _ref2[0],\n        tokenB = _ref2[1];\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        var dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        var dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount;\n      }\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair]);\n  var parsedAmounts = (_parsedAmounts = {}, _defineProperty(_parsedAmounts, Field.CURRENCY_A, independentField === Field.CURRENCY_A ? independentAmount : dependentAmount), _defineProperty(_parsedAmounts, Field.CURRENCY_B, independentField === Field.CURRENCY_A ? dependentAmount : independentAmount), _parsedAmounts);\n  var price = useMemo(function () {\n    if (noLiquidity) {\n      var _currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n        _currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n      if (_currencyAAmount && _currencyBAmount) {\n        return new Price(_currencyAAmount.currency, _currencyBAmount.currency, _currencyAAmount.raw, _currencyBAmount.raw);\n      }\n      return undefined;\n    } else {\n      var wrappedCurrencyA = wrappedCurrency(currencyA, chainId);\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]);\n\n  // liquidity minted\n  var liquidityMinted = useMemo(function () {\n    var currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n      currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n    var _ref3 = [wrappedCurrencyAmount(currencyAAmount, chainId), wrappedCurrencyAmount(currencyBAmount, chainId)],\n      tokenAmountA = _ref3[0],\n      tokenAmountB = _ref3[1];\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n  var poolTokenPercentage = useMemo(function () {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  var error;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (pairState === PairState.INVALID) {\n    var _error;\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Invalid pair';\n  }\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n  var currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n    currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n    error = 'Insufficient ' + ((_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol) + ' balance';\n  }\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n    error = 'Insufficient ' + ((_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol) + ' balance';\n  }\n  return {\n    dependentField: dependentField,\n    currencies: currencies,\n    pair: pair,\n    pairState: pairState,\n    currencyBalances: currencyBalances,\n    parsedAmounts: parsedAmounts,\n    price: price,\n    noLiquidity: noLiquidity,\n    liquidityMinted: liquidityMinted,\n    poolTokenPercentage: poolTokenPercentage,\n    error: error\n  };\n}","map":{"version":3,"names":["CurrencyAmount","ETHER","JSBI","Percent","Price","useCallback","useMemo","useDispatch","useSelector","PairState","usePair","useTotalSupply","useActiveWeb3React","wrappedCurrency","wrappedCurrencyAmount","tryParseAmount","useCurrencyBalances","Field","typeInput","ZERO","BigInt","useMintState","state","mint","useMintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","useDerivedMintInfo","currencyA","currencyB","_currencyBalances","_parsedAmounts","_currencyBalances$Fie","_currencyBalances$Fie2","_useActiveWeb3React","account","chainId","_useMintState","independentField","otherTypedValue","dependentField","currencies","_ref","_defineProperty","undefined","_usePair","_usePair2","_slicedToArray","pairState","pair","totalSupply","liquidityToken","NOT_EXISTS","Boolean","equal","raw","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","_ref2","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","ether","parsedAmounts","price","currencyAAmount","currencyBAmount","currency","wrappedCurrencyA","liquidityMinted","_ref3","tokenAmountA","tokenAmountB","getLiquidityMinted","poolTokenPercentage","add","error","INVALID","_error","_error2","lessThan","_currencies$Field$CUR","symbol","_currencies$Field$CUR2"],"sources":["E:/testprojects/CoolSwap-interface/src/state/mint/hooks.ts"],"sourcesContent":["import { Currency, CurrencyAmount, ETHER, JSBI, Pair, Percent, Price, TokenAmount } from '@uniswap/sdk';\r\nimport { useCallback, useMemo } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { PairState, usePair } from '../../data/Reserves';\r\nimport { useTotalSupply } from '../../data/TotalSupply';\r\n\r\nimport { useActiveWeb3React } from '../../hooks';\r\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency';\r\nimport { AppDispatch, AppState } from '../index';\r\nimport { tryParseAmount } from '../swap/hooks';\r\nimport { useCurrencyBalances } from '../wallet/hooks';\r\nimport { Field, typeInput } from './actions';\r\n\r\nconst ZERO = JSBI.BigInt(0);\r\n\r\nexport function useMintState(): AppState['mint'] {\r\n  return useSelector<AppState, AppState['mint']>((state) => state.mint);\r\n}\r\n\r\nexport function useMintActionHandlers(noLiquidity: boolean | undefined): {\r\n  onFieldAInput: (typedValue: string) => void;\r\n  onFieldBInput: (typedValue: string) => void;\r\n} {\r\n  const dispatch = useDispatch<AppDispatch>();\r\n\r\n  const onFieldAInput = useCallback(\r\n    (typedValue: string) => {\r\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }));\r\n    },\r\n    [dispatch, noLiquidity]\r\n  );\r\n  const onFieldBInput = useCallback(\r\n    (typedValue: string) => {\r\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }));\r\n    },\r\n    [dispatch, noLiquidity]\r\n  );\r\n\r\n  return {\r\n    onFieldAInput,\r\n    onFieldBInput,\r\n  };\r\n}\r\n\r\nexport function useDerivedMintInfo(\r\n  currencyA: Currency | undefined,\r\n  currencyB: Currency | undefined\r\n): {\r\n  dependentField: Field;\r\n  currencies: { [field in Field]?: Currency };\r\n  pair?: Pair | null;\r\n  pairState: PairState;\r\n  currencyBalances: { [field in Field]?: CurrencyAmount };\r\n  parsedAmounts: { [field in Field]?: CurrencyAmount };\r\n  price?: Price;\r\n  noLiquidity?: boolean;\r\n  liquidityMinted?: TokenAmount;\r\n  poolTokenPercentage?: Percent;\r\n  error?: string;\r\n} {\r\n  const { account, chainId } = useActiveWeb3React();\r\n\r\n  const { independentField, typedValue, otherTypedValue } = useMintState();\r\n\r\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\r\n\r\n  // tokens\r\n  const currencies: { [field in Field]?: Currency } = useMemo(\r\n    () => ({\r\n      [Field.CURRENCY_A]: currencyA ?? undefined,\r\n      [Field.CURRENCY_B]: currencyB ?? undefined,\r\n    }),\r\n    [currencyA, currencyB]\r\n  );\r\n\r\n  // pair\r\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\r\n  const totalSupply = useTotalSupply(pair?.liquidityToken);\r\n\r\n  const noLiquidity: boolean =\r\n    pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO));\r\n\r\n  // balances\r\n  const balances = useCurrencyBalances(account ?? undefined, [\r\n    currencies[Field.CURRENCY_A],\r\n    currencies[Field.CURRENCY_B],\r\n  ]);\r\n  const currencyBalances: { [field in Field]?: CurrencyAmount } = {\r\n    [Field.CURRENCY_A]: balances[0],\r\n    [Field.CURRENCY_B]: balances[1],\r\n  };\r\n\r\n  // amounts\r\n  const independentAmount: CurrencyAmount | undefined = tryParseAmount(typedValue, currencies[independentField]);\r\n  const dependentAmount: CurrencyAmount | undefined = useMemo(() => {\r\n    if (noLiquidity) {\r\n      if (otherTypedValue && currencies[dependentField]) {\r\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\r\n      }\r\n      return undefined;\r\n    } else if (independentAmount) {\r\n      // we wrap the currencies just to get the price in terms of the other token\r\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\r\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];\r\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\r\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\r\n        const dependentTokenAmount =\r\n          dependentField === Field.CURRENCY_B\r\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\r\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\r\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount;\r\n      }\r\n      return undefined;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }, [\r\n    noLiquidity,\r\n    otherTypedValue,\r\n    currencies,\r\n    dependentField,\r\n    independentAmount,\r\n    currencyA,\r\n    chainId,\r\n    currencyB,\r\n    pair,\r\n  ]);\r\n  const parsedAmounts: { [field in Field]: CurrencyAmount | undefined } = {\r\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\r\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\r\n  };\r\n\r\n  const price = useMemo(() => {\r\n    if (noLiquidity) {\r\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts;\r\n      if (currencyAAmount && currencyBAmount) {\r\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\r\n      }\r\n      return undefined;\r\n    } else {\r\n      const wrappedCurrencyA = wrappedCurrency(currencyA, chainId);\r\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\r\n    }\r\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]);\r\n\r\n  // liquidity minted\r\n  const liquidityMinted = useMemo(() => {\r\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts;\r\n    const [tokenAmountA, tokenAmountB] = [\r\n      wrappedCurrencyAmount(currencyAAmount, chainId),\r\n      wrappedCurrencyAmount(currencyBAmount, chainId),\r\n    ];\r\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\r\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }, [parsedAmounts, chainId, pair, totalSupply]);\r\n\r\n  const poolTokenPercentage = useMemo(() => {\r\n    if (liquidityMinted && totalSupply) {\r\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }, [liquidityMinted, totalSupply]);\r\n\r\n  let error: string | undefined;\r\n  if (!account) {\r\n    error = 'Connect Wallet';\r\n  }\r\n\r\n  if (pairState === PairState.INVALID) {\r\n    error = error ?? 'Invalid pair';\r\n  }\r\n\r\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\r\n    error = error ?? 'Enter an amount';\r\n  }\r\n\r\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts;\r\n\r\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\r\n    error = 'Insufficient ' + currencies[Field.CURRENCY_A]?.symbol + ' balance';\r\n  }\r\n\r\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\r\n    error = 'Insufficient ' + currencies[Field.CURRENCY_B]?.symbol + ' balance';\r\n  }\r\n\r\n  return {\r\n    dependentField,\r\n    currencies,\r\n    pair,\r\n    pairState,\r\n    currencyBalances,\r\n    parsedAmounts,\r\n    price,\r\n    noLiquidity,\r\n    liquidityMinted,\r\n    poolTokenPercentage,\r\n    error,\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}