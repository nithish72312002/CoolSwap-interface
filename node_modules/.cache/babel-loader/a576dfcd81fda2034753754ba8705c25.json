{"ast":null,"code":"import _toConsumableArray from \"E:\\\\testprojects\\\\CoolSwap-interface\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"E:\\\\testprojects\\\\CoolSwap-interface\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { isTradeBetter } from 'utils/trades';\nimport { Trade } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useActiveWeb3React } from './index';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\nfunction useAllCommonPairs(currencyA, currencyB) {\n  var _useActiveWeb3React = useActiveWeb3React(),\n    chainId = _useActiveWeb3React.chainId;\n  var bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\n  var _ref = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined],\n    _ref2 = _slicedToArray(_ref, 2),\n    tokenA = _ref2[0],\n    tokenB = _ref2[1];\n  var basePairs = useMemo(function () {\n    return flatMap(bases, function (base) {\n      return bases.map(function (otherBase) {\n        return [base, otherBase];\n      });\n    }).filter(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        t0 = _ref4[0],\n        t1 = _ref4[1];\n      return t0.address !== t1.address;\n    });\n  }, [bases]);\n  var allPairCombinations = useMemo(function () {\n    return tokenA && tokenB ? [\n    // the direct pair\n    [tokenA, tokenB]].concat(_toConsumableArray(bases.map(function (base) {\n      return [tokenA, base];\n    })), _toConsumableArray(bases.map(function (base) {\n      return [tokenB, base];\n    })), _toConsumableArray(basePairs)).filter(function (tokens) {\n      return Boolean(tokens[0] && tokens[1]);\n    }).filter(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        t0 = _ref6[0],\n        t1 = _ref6[1];\n      return t0.address !== t1.address;\n    }).filter(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n        tokenA = _ref8[0],\n        tokenB = _ref8[1];\n      if (!chainId) return true;\n      var customBases = CUSTOM_BASES[chainId];\n      if (!customBases) return true;\n      var customBasesA = customBases[tokenA.address];\n      var customBasesB = customBases[tokenB.address];\n      if (!customBasesA && !customBasesB) return true;\n      if (customBasesA && !customBasesA.find(function (base) {\n        return tokenB.equals(base);\n      })) return false;\n      if (customBasesB && !customBasesB.find(function (base) {\n        return tokenA.equals(base);\n      })) return false;\n      return true;\n    }) : [];\n  }, [tokenA, tokenB, bases, basePairs, chainId]);\n  var allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(function () {\n    return Object.values(allPairs\n    // filter out invalid pairs\n    .filter(function (result) {\n      return Boolean(result[0] === PairState.EXISTS && result[1]);\n    })\n    // filter out duplicated pairs\n    .reduce(function (memo, _ref9) {\n      var _memo$curr$liquidityT;\n      var _ref10 = _slicedToArray(_ref9, 2),\n        curr = _ref10[1];\n      memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n      return memo;\n    }, {}));\n  }, [allPairs]);\n}\nvar MAX_HOPS = 3;\n\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  var allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  var _useUserSingleHopOnly = useUserSingleHopOnly(),\n    _useUserSingleHopOnly2 = _slicedToArray(_useUserSingleHopOnly, 1),\n    singleHopOnly = _useUserSingleHopOnly2[0];\n  return useMemo(function () {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n        return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n      }\n      // search through trades with varying hops, find best trade out of them\n      var bestTradeSoFar = null;\n      for (var i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n        var currentTrade = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  var allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  var _useUserSingleHopOnly3 = useUserSingleHopOnly(),\n    _useUserSingleHopOnly4 = _slicedToArray(_useUserSingleHopOnly3, 1),\n    singleHopOnly = _useUserSingleHopOnly4[0];\n  return useMemo(function () {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n        return (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n      }\n      // search through trades with varying hops, find best trade out of them\n      var bestTradeSoFar = null;\n      for (var i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n        var currentTrade = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}","map":{"version":3,"names":["isTradeBetter","Trade","flatMap","useMemo","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","BETTER_TRADE_LESS_HOPS_THRESHOLD","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useUserSingleHopOnly","useAllCommonPairs","currencyA","currencyB","_useActiveWeb3React","chainId","bases","_ref","undefined","_ref2","_slicedToArray","tokenA","tokenB","basePairs","base","map","otherBase","filter","_ref3","_ref4","t0","t1","address","allPairCombinations","concat","_toConsumableArray","tokens","Boolean","_ref5","_ref6","_ref7","_ref8","customBases","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","_ref9","_memo$curr$liquidityT","_ref10","curr","liquidityToken","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","_useUserSingleHopOnly","_useUserSingleHopOnly2","singleHopOnly","length","_Trade$bestTradeExact","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","_Trade$bestTradeExact2","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","_useUserSingleHopOnly3","_useUserSingleHopOnly4","_Trade$bestTradeExact3","bestTradeExactOut","_Trade$bestTradeExact4"],"sources":["E:/testprojects/CoolSwap-interface/src/hooks/Trades.ts"],"sourcesContent":["import { isTradeBetter } from 'utils/trades';\r\nimport { Currency, CurrencyAmount, Pair, Token, Trade } from '@uniswap/sdk';\r\nimport flatMap from 'lodash.flatmap';\r\nimport { useMemo } from 'react';\r\n\r\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants';\r\nimport { PairState, usePairs } from '../data/Reserves';\r\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\r\n\r\nimport { useActiveWeb3React } from './index';\r\nimport { useUserSingleHopOnly } from 'state/user/hooks';\r\n\r\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\r\n  const { chainId } = useActiveWeb3React();\r\n\r\n  const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\r\n\r\n  const [tokenA, tokenB] = chainId\r\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\r\n    : [undefined, undefined];\r\n\r\n  const basePairs: [Token, Token][] = useMemo(\r\n    () =>\r\n      flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])).filter(\r\n        ([t0, t1]) => t0.address !== t1.address\r\n      ),\r\n    [bases]\r\n  );\r\n\r\n  const allPairCombinations: [Token, Token][] = useMemo(\r\n    () =>\r\n      tokenA && tokenB\r\n        ? [\r\n            // the direct pair\r\n            [tokenA, tokenB],\r\n            // token A against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\r\n            // token B against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\r\n            // each base against all bases\r\n            ...basePairs,\r\n          ]\r\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\r\n            .filter(([t0, t1]) => t0.address !== t1.address)\r\n            .filter(([tokenA, tokenB]) => {\r\n              if (!chainId) return true;\r\n              const customBases = CUSTOM_BASES[chainId];\r\n              if (!customBases) return true;\r\n\r\n              const customBasesA: Token[] | undefined = customBases[tokenA.address];\r\n              const customBasesB: Token[] | undefined = customBases[tokenB.address];\r\n\r\n              if (!customBasesA && !customBasesB) return true;\r\n\r\n              if (customBasesA && !customBasesA.find((base) => tokenB.equals(base))) return false;\r\n              if (customBasesB && !customBasesB.find((base) => tokenA.equals(base))) return false;\r\n\r\n              return true;\r\n            })\r\n        : [],\r\n    [tokenA, tokenB, bases, basePairs, chainId]\r\n  );\r\n\r\n  const allPairs = usePairs(allPairCombinations);\r\n\r\n  // only pass along valid pairs, non-duplicated pairs\r\n  return useMemo(\r\n    () =>\r\n      Object.values(\r\n        allPairs\r\n          // filter out invalid pairs\r\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\r\n          // filter out duplicated pairs\r\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\r\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr;\r\n            return memo;\r\n          }, {})\r\n      ),\r\n    [allPairs]\r\n  );\r\n}\r\n\r\nconst MAX_HOPS = 3;\r\n\r\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\r\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut);\r\n\r\n  const [singleHopOnly] = useUserSingleHopOnly();\r\n\r\n  return useMemo(() => {\r\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\r\n      if (singleHopOnly) {\r\n        return (\r\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\r\n          null\r\n        );\r\n      }\r\n      // search through trades with varying hops, find best trade out of them\r\n      let bestTradeSoFar: Trade | null = null;\r\n      for (let i = 1; i <= MAX_HOPS; i++) {\r\n        const currentTrade: Trade | null =\r\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\r\n          null;\r\n        // if current trade is best yet, save it\r\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\r\n          bestTradeSoFar = currentTrade;\r\n        }\r\n      }\r\n      return bestTradeSoFar;\r\n    }\r\n\r\n    return null;\r\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\r\n}\r\n\r\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\r\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency);\r\n\r\n  const [singleHopOnly] = useUserSingleHopOnly();\r\n\r\n  return useMemo(() => {\r\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\r\n      if (singleHopOnly) {\r\n        return (\r\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\r\n          null\r\n        );\r\n      }\r\n      // search through trades with varying hops, find best trade out of them\r\n      let bestTradeSoFar: Trade | null = null;\r\n      for (let i = 1; i <= MAX_HOPS; i++) {\r\n        const currentTrade =\r\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\r\n          null;\r\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\r\n          bestTradeSoFar = currentTrade;\r\n        }\r\n      }\r\n      return bestTradeSoFar;\r\n    }\r\n    return null;\r\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}