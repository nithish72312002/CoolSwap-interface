{"ast":null,"code":"/**\n * Multihash implementation in JavaScript.\n */\n'use strict';\n\nvar multibase = require('multibase');\nvar varint = require('varint');\nvar _require = require('./constants'),\n  names = _require.names;\nvar uint8ArrayToString = require('uint8arrays/to-string');\nvar uint8ArrayFromString = require('uint8arrays/from-string');\nvar uint8ArrayConcat = require('uint8arrays/concat');\nvar codes = /** @type {import('./types').CodeNameMap} */{};\n\n// eslint-disable-next-line guard-for-in\nfor (var key in names) {\n  var name = /** @type {HashName} */key;\n  codes[names[name]] = name;\n}\nObject.freeze(codes);\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n  return uint8ArrayToString(hash, 'base16');\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString(hash) {\n  return uint8ArrayFromString(hash, 'base16');\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String(hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array');\n  }\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1);\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String(hash) {\n  var encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;\n  return multibase.decode('z' + encoded);\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array');\n  }\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n  var code = /** @type {HashCode} */varint.decode(bytes);\n  if (!isValidCode(code)) {\n    throw new Error(\"multihash unknown function code: 0x\".concat(code.toString(16)));\n  }\n  bytes = bytes.slice(varint.decode.bytes);\n  var len = varint.decode(bytes);\n  if (len < 0) {\n    throw new Error(\"multihash invalid length: \".concat(len));\n  }\n  bytes = bytes.slice(varint.decode.bytes);\n  if (bytes.length !== len) {\n    throw new Error(\"multihash length inconsistent: 0x\".concat(uint8ArrayToString(bytes, 'base16')));\n  }\n  return {\n    code: code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  };\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  }\n\n  // ensure it's a hashfunction code.\n  var hashfn = coerceCode(code);\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array');\n  }\n  if (length == null) {\n    length = digest.length;\n  }\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n  var hash = varint.encode(hashfn);\n  var len = varint.encode(length);\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode(name) {\n  var code = name;\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(\"Unrecognized hash function named: \".concat(name));\n    }\n    code = names[name];\n  }\n  if (typeof code !== 'number') {\n    throw new Error(\"Hash function code should be a number. Got: \".concat(code));\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(\"Unrecognized function code: \".concat(code));\n  }\n  return code;\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode(code) {\n  return code > 0 && code < 0x10;\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode(code) {\n  if (isAppCode(code)) {\n    return true;\n  }\n  if (codes[code]) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate(multihash) {\n  decode(multihash); // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix(multihash) {\n  validate(multihash);\n  return multihash.subarray(0, 2);\n}\nmodule.exports = {\n  names: names,\n  codes: codes,\n  toHexString: toHexString,\n  fromHexString: fromHexString,\n  toB58String: toB58String,\n  fromB58String: fromB58String,\n  decode: decode,\n  encode: encode,\n  coerceCode: coerceCode,\n  isAppCode: isAppCode,\n  validate: validate,\n  prefix: prefix,\n  isValidCode: isValidCode\n};\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */","map":{"version":3,"names":["multibase","require","varint","_require","names","uint8ArrayToString","uint8ArrayFromString","uint8ArrayConcat","codes","key","name","Object","freeze","toHexString","hash","Uint8Array","Error","fromHexString","toB58String","encode","slice","fromB58String","encoded","decode","bytes","length","code","isValidCode","concat","toString","len","digest","undefined","hashfn","coerceCode","isAppCode","validate","multihash","prefix","subarray","module","exports"],"sources":["E:/testprojects/CoolSwap-interface/node_modules/multihashes/src/index.js"],"sourcesContent":["/**\n * Multihash implementation in JavaScript.\n */\n'use strict'\n\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst { names } = require('./constants')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\nconst uint8ArrayConcat = require('uint8arrays/concat')\n\nconst codes = /** @type {import('./types').CodeNameMap} */({})\n\n// eslint-disable-next-line guard-for-in\nfor (const key in names) {\n  const name = /** @type {HashName} */(key)\n  codes[names[name]] = name\n}\nObject.freeze(codes)\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toHexString (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(hash, 'base16')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Uint8Array}\n */\nfunction fromHexString (hash) {\n  return uint8ArrayFromString(hash, 'base16')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Uint8Array} hash\n * @returns {string}\n */\nfunction toB58String (hash) {\n  if (!(hash instanceof Uint8Array)) {\n    throw new Error('must be passed a Uint8Array')\n  }\n\n  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Uint8Array} hash\n * @returns {Uint8Array}\n */\nfunction fromB58String (hash) {\n  const encoded = hash instanceof Uint8Array\n    ? uint8ArrayToString(hash)\n    : hash\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Uint8Array} bytes\n * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result\n */\nfunction decode (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new Error('multihash must be a Uint8Array')\n  }\n\n  if (bytes.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = /** @type {HashCode} */(varint.decode(bytes))\n  if (!isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  const len = varint.decode(bytes)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  bytes = bytes.slice(varint.decode.bytes)\n\n  if (bytes.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: bytes\n  }\n}\n\n/**\n * Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Uint8Array} digest\n * @param {HashName | HashCode} code\n * @param {number} [length]\n * @returns {Uint8Array}\n */\nfunction encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = coerceCode(code)\n\n  if (!(digest instanceof Uint8Array)) {\n    throw new Error('digest should be a Uint8Array')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  const hash = varint.encode(hashfn)\n  const len = varint.encode(length)\n  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n *\n * @param {HashName | number} name\n * @returns {number}\n */\nfunction coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  // @ts-ignore\n  if (codes[code] === undefined && !isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks if a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction isAppCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {HashCode} code\n * @returns {boolean}\n */\nfunction isValidCode (code) {\n  if (isAppCode(code)) {\n    return true\n  }\n\n  if (codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {void}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  decode(multihash) // throws if bad.\n}\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n * @throws {Error}\n */\nfunction prefix (multihash) {\n  validate(multihash)\n\n  return multihash.subarray(0, 2)\n}\n\nmodule.exports = {\n  names,\n  codes,\n  toHexString,\n  fromHexString,\n  toB58String,\n  fromB58String,\n  decode,\n  encode,\n  coerceCode,\n  isAppCode,\n  validate,\n  prefix,\n  isValidCode\n}\n\n/**\n * @typedef { import(\"./constants\").HashCode } HashCode\n * @typedef { import(\"./constants\").HashName } HashName\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}