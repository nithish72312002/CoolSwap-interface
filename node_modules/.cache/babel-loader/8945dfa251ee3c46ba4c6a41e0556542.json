{"ast":null,"code":"import { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, removeMulticallListeners, parseCallKey, toCallKey } from './actions';\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(function (xi) {\n    return isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg);\n  });\n}\nvar INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\n\n// use this options object\nexport var NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls, options) {\n  var _useActiveWeb3React = useActiveWeb3React(),\n    chainId = _useActiveWeb3React.chainId;\n  var callResults = useSelector(function (state) {\n    return state.multicall.callResults;\n  });\n  var dispatch = useDispatch();\n  var serializedCallKeys = useMemo(function () {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(function (c) {\n      return Boolean(c);\n    })) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]);\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(function () {\n    var callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    var calls = callKeys.map(function (key) {\n      return parseCallKey(key);\n    });\n    dispatch(addMulticallListeners({\n      chainId: chainId,\n      calls: calls,\n      options: options\n    }));\n    return function () {\n      dispatch(removeMulticallListeners({\n        chainId: chainId,\n        calls: calls,\n        options: options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(function () {\n    return calls.map(function (call) {\n      var _callResults$chainId;\n      if (!chainId || !call) return INVALID_RESULT;\n      var result = (_callResults$chainId = callResults[chainId]) === null || _callResults$chainId === void 0 ? void 0 : _callResults$chainId[toCallKey(call)];\n      var data;\n      if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n        data = result.data;\n      }\n      return {\n        valid: true,\n        data: data,\n        blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n      };\n    });\n  }, [callResults, calls, chainId]);\n}\nvar INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nvar LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  var valid = callResult.valid,\n    data = callResult.data,\n    blockNumber = callResult.blockNumber;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  var success = data && data.length > 2;\n  var syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  var result = undefined;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing: syncing,\n        result: result\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing: syncing,\n    result: result,\n    error: !success\n  };\n}\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  var fragment = useMemo(function () {\n    var _contract$interface;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  var calls = useMemo(function () {\n    return contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(function (inputs) {\n      return {\n        address: contract.address,\n        callData: contract.interface.encodeFunctionData(fragment, inputs)\n      };\n    }) : [];\n  }, [callInputs, contract, fragment]);\n  var results = useCallsData(calls, options);\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n    });\n  }, [fragment, contract, results, latestBlockNumber]);\n}\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  var fragment = useMemo(function () {\n    return contractInterface.getFunction(methodName);\n  }, [contractInterface, methodName]);\n  var callData = useMemo(function () {\n    return fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined;\n  }, [callInputs, contractInterface, fragment]);\n  var calls = useMemo(function () {\n    return fragment && addresses && addresses.length > 0 && callData ? addresses.map(function (address) {\n      return address && callData ? {\n        address: address,\n        callData: callData\n      } : undefined;\n    }) : [];\n  }, [addresses, callData, fragment]);\n  var results = useCallsData(calls, options);\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contractInterface, fragment, latestBlockNumber);\n    });\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  var fragment = useMemo(function () {\n    var _contract$interface2;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  var calls = useMemo(function () {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  var result = useCallsData(calls, options)[0];\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}","map":{"version":3,"names":["useEffect","useMemo","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","_useActiveWeb3React","chainId","callResults","state","multicall","dispatch","serializedCallKeys","_calls$filter$map$sor","_calls$filter","_calls$filter$map","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","_callResults$chainId","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","_contract$interface","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult","_contract$interface2"],"sources":["E:/testprojects/CoolSwap-interface/src/state/multicall/hooks.ts"],"sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi';\r\nimport { BigNumber } from '@ethersproject/bignumber';\r\nimport { Contract } from '@ethersproject/contracts';\r\nimport { useEffect, useMemo } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { useActiveWeb3React } from '../../hooks';\r\nimport { useBlockNumber } from '../application/hooks';\r\nimport { AppDispatch, AppState } from '../index';\r\nimport {\r\n  addMulticallListeners,\r\n  Call,\r\n  removeMulticallListeners,\r\n  parseCallKey,\r\n  toCallKey,\r\n  ListenerOptions,\r\n} from './actions';\r\n\r\nexport interface Result extends ReadonlyArray<any> {\r\n  readonly [key: string]: any;\r\n}\r\n\r\ntype MethodArg = string | number | BigNumber;\r\ntype MethodArgs = Array<MethodArg | MethodArg[]>;\r\n\r\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined;\r\n\r\nfunction isMethodArg(x: unknown): x is MethodArg {\r\n  return ['string', 'number'].indexOf(typeof x) !== -1;\r\n}\r\n\r\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\r\n  return (\r\n    x === undefined ||\r\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\r\n  );\r\n}\r\n\r\ninterface CallResult {\r\n  readonly valid: boolean;\r\n  readonly data: string | undefined;\r\n  readonly blockNumber: number | undefined;\r\n}\r\n\r\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined };\r\n\r\n// use this options object\r\nexport const NEVER_RELOAD: ListenerOptions = {\r\n  blocksPerFetch: Infinity,\r\n};\r\n\r\n// the lowest level call for subscribing to contract data\r\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\r\n  const { chainId } = useActiveWeb3React();\r\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(\r\n    (state) => state.multicall.callResults\r\n  );\r\n  const dispatch = useDispatch<AppDispatch>();\r\n\r\n  const serializedCallKeys: string = useMemo(\r\n    () =>\r\n      JSON.stringify(\r\n        calls\r\n          ?.filter((c): c is Call => Boolean(c))\r\n          ?.map(toCallKey)\r\n          ?.sort() ?? []\r\n      ),\r\n    [calls]\r\n  );\r\n\r\n  // update listeners when there is an actual change that persists for at least 100ms\r\n  useEffect(() => {\r\n    const callKeys: string[] = JSON.parse(serializedCallKeys);\r\n    if (!chainId || callKeys.length === 0) return undefined;\r\n    const calls = callKeys.map((key) => parseCallKey(key));\r\n    dispatch(\r\n      addMulticallListeners({\r\n        chainId,\r\n        calls,\r\n        options,\r\n      })\r\n    );\r\n\r\n    return () => {\r\n      dispatch(\r\n        removeMulticallListeners({\r\n          chainId,\r\n          calls,\r\n          options,\r\n        })\r\n      );\r\n    };\r\n  }, [chainId, dispatch, options, serializedCallKeys]);\r\n\r\n  return useMemo(\r\n    () =>\r\n      calls.map<CallResult>((call) => {\r\n        if (!chainId || !call) return INVALID_RESULT;\r\n\r\n        const result = callResults[chainId]?.[toCallKey(call)];\r\n        let data;\r\n        if (result?.data && result?.data !== '0x') {\r\n          data = result.data;\r\n        }\r\n\r\n        return { valid: true, data, blockNumber: result?.blockNumber };\r\n      }),\r\n    [callResults, calls, chainId]\r\n  );\r\n}\r\n\r\ninterface CallState {\r\n  readonly valid: boolean;\r\n  // the result, or undefined if loading or errored/no data\r\n  readonly result: Result | undefined;\r\n  // true if the result has never been fetched\r\n  readonly loading: boolean;\r\n  // true if the result is not for the latest block\r\n  readonly syncing: boolean;\r\n  // true if the call was made and is synced, but the return data is invalid\r\n  readonly error: boolean;\r\n}\r\n\r\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false };\r\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false };\r\n\r\nfunction toCallState(\r\n  callResult: CallResult | undefined,\r\n  contractInterface: Interface | undefined,\r\n  fragment: FunctionFragment | undefined,\r\n  latestBlockNumber: number | undefined\r\n): CallState {\r\n  if (!callResult) return INVALID_CALL_STATE;\r\n  const { valid, data, blockNumber } = callResult;\r\n  if (!valid) return INVALID_CALL_STATE;\r\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\r\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\r\n  const success = data && data.length > 2;\r\n  const syncing = (blockNumber ?? 0) < latestBlockNumber;\r\n  let result: Result | undefined = undefined;\r\n  if (success && data) {\r\n    try {\r\n      result = contractInterface.decodeFunctionResult(fragment, data);\r\n    } catch (error) {\r\n      console.debug('Result data parsing failed', fragment, data);\r\n      return {\r\n        valid: true,\r\n        loading: false,\r\n        error: true,\r\n        syncing,\r\n        result,\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    valid: true,\r\n    loading: false,\r\n    syncing,\r\n    result: result,\r\n    error: !success,\r\n  };\r\n}\r\n\r\nexport function useSingleContractMultipleData(\r\n  contract: Contract | null | undefined,\r\n  methodName: string,\r\n  callInputs: OptionalMethodInputs[],\r\n  options?: ListenerOptions\r\n): CallState[] {\r\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName]);\r\n\r\n  const calls = useMemo(\r\n    () =>\r\n      contract && fragment && callInputs && callInputs.length > 0\r\n        ? callInputs.map<Call>((inputs) => {\r\n            return {\r\n              address: contract.address,\r\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\r\n            };\r\n          })\r\n        : [],\r\n    [callInputs, contract, fragment]\r\n  );\r\n\r\n  const results = useCallsData(calls, options);\r\n\r\n  const latestBlockNumber = useBlockNumber();\r\n\r\n  return useMemo(() => {\r\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber));\r\n  }, [fragment, contract, results, latestBlockNumber]);\r\n}\r\n\r\nexport function useMultipleContractSingleData(\r\n  addresses: (string | undefined)[],\r\n  contractInterface: Interface,\r\n  methodName: string,\r\n  callInputs?: OptionalMethodInputs,\r\n  options?: ListenerOptions\r\n): CallState[] {\r\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\r\n  const callData: string | undefined = useMemo(\r\n    () =>\r\n      fragment && isValidMethodArgs(callInputs)\r\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\r\n        : undefined,\r\n    [callInputs, contractInterface, fragment]\r\n  );\r\n\r\n  const calls = useMemo(\r\n    () =>\r\n      fragment && addresses && addresses.length > 0 && callData\r\n        ? addresses.map<Call | undefined>((address) => {\r\n            return address && callData\r\n              ? {\r\n                  address,\r\n                  callData,\r\n                }\r\n              : undefined;\r\n          })\r\n        : [],\r\n    [addresses, callData, fragment]\r\n  );\r\n\r\n  const results = useCallsData(calls, options);\r\n\r\n  const latestBlockNumber = useBlockNumber();\r\n\r\n  return useMemo(() => {\r\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber));\r\n  }, [fragment, results, contractInterface, latestBlockNumber]);\r\n}\r\n\r\nexport function useSingleCallResult(\r\n  contract: Contract | null | undefined,\r\n  methodName: string,\r\n  inputs?: OptionalMethodInputs,\r\n  options?: ListenerOptions\r\n): CallState {\r\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName]);\r\n\r\n  const calls = useMemo<Call[]>(() => {\r\n    return contract && fragment && isValidMethodArgs(inputs)\r\n      ? [\r\n          {\r\n            address: contract.address,\r\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\r\n          },\r\n        ]\r\n      : [];\r\n  }, [contract, fragment, inputs]);\r\n\r\n  const result = useCallsData(calls, options)[0];\r\n  const latestBlockNumber = useBlockNumber();\r\n\r\n  return useMemo(() => {\r\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber);\r\n  }, [result, contract, fragment, latestBlockNumber]);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}