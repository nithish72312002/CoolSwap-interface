{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"E:\\\\testprojects\\\\CoolSwap-interface\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nvar modular_js_1 = require(\"./modular.js\");\nvar utils_js_1 = require(\"./utils.js\");\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n  var constTimeNegate = function constTimeNegate(condition, item) {\n    var neg = item.negate();\n    return condition ? neg : item;\n  };\n  var opts = function opts(W) {\n    var windows = Math.ceil(bits / W) + 1; // +1, because\n    var windowSize = Math.pow(2, W - 1); // -1 because we skip zero\n    return {\n      windows: windows,\n      windowSize: windowSize\n    };\n  };\n  return {\n    constTimeNegate: constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder: function unsafeLadder(elm, n) {\n      var p = c.ZERO;\n      var d = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow: function precomputeWindow(elm, W) {\n      var _opts = opts(W),\n        windows = _opts.windows,\n        windowSize = _opts.windowSize;\n      var points = [];\n      var p = elm;\n      var base = p;\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (var i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF: function wNAF(W, precomputes, n) {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      var _opts2 = opts(W),\n        windows = _opts2.windows,\n        windowSize = _opts2.windowSize;\n      var p = c.ZERO;\n      var f = c.BASE;\n      var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        // Extract W bits.\n        var wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        var offset1 = offset;\n        var offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        var cond1 = window % 2 !== 0;\n        var cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return {\n        p: p,\n        f: f\n      };\n    },\n    wNAFCached: function wNAFCached(P, precomputesMap, n, transform) {\n      // @ts-ignore\n      var W = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      var comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W);\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    }\n  };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n  (0, modular_js_1.validateField)(curve.Fp);\n  (0, utils_js_1.validateObject)(curve, {\n    n: 'bigint',\n    h: 'bigint',\n    Gx: 'field',\n    Gy: 'field'\n  }, {\n    nBitLength: 'isSafeInteger',\n    nByteLength: 'isSafeInteger'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread(_objectSpread(_objectSpread({}, (0, modular_js_1.nLength)(curve.n, curve.nBitLength)), curve), {\n    p: curve.Fp.ORDER\n  }));\n}\nexports.validateBasic = validateBasic;","map":{"version":3,"names":["modular_js_1","require","utils_js_1","_0n","BigInt","_1n","wNAF","c","bits","constTimeNegate","condition","item","neg","negate","opts","W","windows","Math","ceil","windowSize","pow","unsafeLadder","elm","n","p","ZERO","d","add","double","precomputeWindow","_opts","points","base","window","push","i","precomputes","_opts2","f","BASE","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","abs","cond1","cond2","wNAFCached","P","precomputesMap","transform","_WINDOW_SIZE","comp","get","set","exports","validateBasic","curve","validateField","Fp","validateObject","h","Gx","Gy","nBitLength","nByteLength","Object","freeze","_objectSpread","nLength","ORDER"],"sources":["../src/abstract/curve.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}