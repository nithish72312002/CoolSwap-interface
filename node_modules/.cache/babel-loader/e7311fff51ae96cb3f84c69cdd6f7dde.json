{"ast":null,"code":"import { useAllLists } from 'state/lists/hooks';\nimport { getVersionUpgrade, minVersionBump, VersionUpgrade } from '@uniswap/token-lists';\nimport { useCallback, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useFetchListCallback } from '../../hooks/useFetchListCallback';\nimport useInterval from '../../hooks/useInterval';\nimport useIsWindowVisible from '../../hooks/useIsWindowVisible';\nimport { acceptListUpdate } from './actions';\nimport { useActiveListUrls } from './hooks';\nimport { useAllInactiveTokens } from 'hooks/Tokens';\nexport default function Updater() {\n  var _useActiveWeb3React = useActiveWeb3React(),\n    library = _useActiveWeb3React.library;\n  var dispatch = useDispatch();\n  var isWindowVisible = useIsWindowVisible();\n\n  // get all loaded lists, and the active urls\n  var lists = useAllLists();\n  var activeListUrls = useActiveListUrls();\n\n  // initiate loading\n  useAllInactiveTokens();\n  var fetchList = useFetchListCallback();\n  var fetchAllListsCallback = useCallback(function () {\n    if (!isWindowVisible) return;\n    Object.keys(lists).forEach(function (url) {\n      return fetchList(url).catch(function (error) {\n        return console.debug('interval list fetching error', error);\n      });\n    });\n  }, [fetchList, isWindowVisible, lists]);\n\n  // fetch all lists every 10 minutes, but only after we initialize library\n  useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null);\n\n  // whenever a list is not loaded and not loading, try again to load it\n  useEffect(function () {\n    Object.keys(lists).forEach(function (listUrl) {\n      var list = lists[listUrl];\n      if (!list.current && !list.loadingRequestId && !list.error) {\n        fetchList(listUrl).catch(function (error) {\n          return console.debug('list added fetching error', error);\n        });\n      }\n    });\n  }, [dispatch, fetchList, library, lists]);\n\n  // automatically update lists if versions are minor/patch\n  useEffect(function () {\n    Object.keys(lists).forEach(function (listUrl) {\n      var list = lists[listUrl];\n      if (list.current && list.pendingUpdate) {\n        var bump = getVersionUpgrade(list.current.version, list.pendingUpdate.version);\n        switch (bump) {\n          case VersionUpgrade.NONE:\n            throw new Error('unexpected no version bump');\n          case VersionUpgrade.PATCH:\n          case VersionUpgrade.MINOR:\n            var min = minVersionBump(list.current.tokens, list.pendingUpdate.tokens);\n            // automatically update minor/patch as long as bump matches the min update\n            if (bump >= min) {\n              dispatch(acceptListUpdate(listUrl));\n            } else {\n              console.error(\"List at url \".concat(listUrl, \" could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR\"));\n            }\n            break;\n          case VersionUpgrade.MAJOR:\n            if (activeListUrls === null || activeListUrls === void 0 ? void 0 : activeListUrls.includes(listUrl)) {\n              dispatch(acceptListUpdate(listUrl));\n            }\n        }\n      }\n    });\n  }, [dispatch, lists, activeListUrls]);\n  return null;\n}","map":{"version":3,"names":["useAllLists","getVersionUpgrade","minVersionBump","VersionUpgrade","useCallback","useEffect","useDispatch","useActiveWeb3React","useFetchListCallback","useInterval","useIsWindowVisible","acceptListUpdate","useActiveListUrls","useAllInactiveTokens","Updater","_useActiveWeb3React","library","dispatch","isWindowVisible","lists","activeListUrls","fetchList","fetchAllListsCallback","Object","keys","forEach","url","catch","error","console","debug","listUrl","list","current","loadingRequestId","pendingUpdate","bump","version","NONE","Error","PATCH","MINOR","min","tokens","concat","MAJOR","includes"],"sources":["E:/testprojects/CoolSwap-interface/src/state/lists/updater.ts"],"sourcesContent":["import { useAllLists } from 'state/lists/hooks';\r\nimport { getVersionUpgrade, minVersionBump, VersionUpgrade } from '@uniswap/token-lists';\r\nimport { useCallback, useEffect } from 'react';\r\nimport { useDispatch } from 'react-redux';\r\nimport { useActiveWeb3React } from '../../hooks';\r\nimport { useFetchListCallback } from '../../hooks/useFetchListCallback';\r\nimport useInterval from '../../hooks/useInterval';\r\nimport useIsWindowVisible from '../../hooks/useIsWindowVisible';\r\nimport { AppDispatch } from '../index';\r\nimport { acceptListUpdate } from './actions';\r\nimport { useActiveListUrls } from './hooks';\r\nimport { useAllInactiveTokens } from 'hooks/Tokens';\r\n\r\nexport default function Updater(): null {\r\n  const { library } = useActiveWeb3React();\r\n  const dispatch = useDispatch<AppDispatch>();\r\n  const isWindowVisible = useIsWindowVisible();\r\n\r\n  // get all loaded lists, and the active urls\r\n  const lists = useAllLists();\r\n  const activeListUrls = useActiveListUrls();\r\n\r\n  // initiate loading\r\n  useAllInactiveTokens();\r\n\r\n  const fetchList = useFetchListCallback();\r\n  const fetchAllListsCallback = useCallback(() => {\r\n    if (!isWindowVisible) return;\r\n    Object.keys(lists).forEach((url) =>\r\n      fetchList(url).catch((error) => console.debug('interval list fetching error', error))\r\n    );\r\n  }, [fetchList, isWindowVisible, lists]);\r\n\r\n  // fetch all lists every 10 minutes, but only after we initialize library\r\n  useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null);\r\n\r\n  // whenever a list is not loaded and not loading, try again to load it\r\n  useEffect(() => {\r\n    Object.keys(lists).forEach((listUrl) => {\r\n      const list = lists[listUrl];\r\n      if (!list.current && !list.loadingRequestId && !list.error) {\r\n        fetchList(listUrl).catch((error) => console.debug('list added fetching error', error));\r\n      }\r\n    });\r\n  }, [dispatch, fetchList, library, lists]);\r\n\r\n  // automatically update lists if versions are minor/patch\r\n  useEffect(() => {\r\n    Object.keys(lists).forEach((listUrl) => {\r\n      const list = lists[listUrl];\r\n      if (list.current && list.pendingUpdate) {\r\n        const bump = getVersionUpgrade(list.current.version, list.pendingUpdate.version);\r\n        switch (bump) {\r\n          case VersionUpgrade.NONE:\r\n            throw new Error('unexpected no version bump');\r\n          case VersionUpgrade.PATCH:\r\n          case VersionUpgrade.MINOR:\r\n            const min = minVersionBump(list.current.tokens, list.pendingUpdate.tokens);\r\n            // automatically update minor/patch as long as bump matches the min update\r\n            if (bump >= min) {\r\n              dispatch(acceptListUpdate(listUrl));\r\n            } else {\r\n              console.error(\r\n                `List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`\r\n              );\r\n            }\r\n            break;\r\n\r\n          case VersionUpgrade.MAJOR:\r\n            if (activeListUrls?.includes(listUrl)) {\r\n              dispatch(acceptListUpdate(listUrl));\r\n            }\r\n        }\r\n      }\r\n    });\r\n  }, [dispatch, lists, activeListUrls]);\r\n\r\n  return null;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}